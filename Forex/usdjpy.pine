// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© UntitledGoose

//@version=5

// For USD/JPY, deciding entry, exit points.
strategy('usdjpy strategy', overlay=true)
rsi = ta.rsi(close, 14)
atr = ta.atr(14)  // Average true range. 

// Calculate MACD slope.
fastMA = ta.ema(close, 12)
slowMA = ta.ema(close, 26)
macd = fastMA - slowMA
signal = ta.ema(macd, 9)
histogram = macd - signal
radians_to_degrees = 180 / 3.14159265359
lookback_period = input(defval=2, title='Lookback periods')
smoothing = input.int(defval=2, minval=2, title='Smoothing')
macd_slope = radians_to_degrees * math.atan((macd[0] - nz(macd[lookback_period])) / lookback_period)
signal_slope = radians_to_degrees * math.atan((signal[0] - nz(signal[lookback_period])) / lookback_period)
histogram_slope = radians_to_degrees * math.atan((histogram[0] - nz(histogram[lookback_period])) / lookback_period)

// Calculate SMA10, 30 slope.
sma_10 = ta.sma(close, 10)
sma_30 = ta.sma(close, 30)
sma_10_slope = radians_to_degrees * math.atan((sma_10[0] - nz(sma_10[lookback_period])) / lookback_period)
sma_30_slope = radians_to_degrees * math.atan((sma_30[0] - nz(sma_30[lookback_period])) / lookback_period)

// Specify crossover conditions.

// Idea 1: Using sma_10, sma_30 cross as entry & exit indicator.
// Result: Decent return. Not stable.
// longCondition = ta.crossover(sma_10, sma_30)  // When sma_10 cross above sma_30.
// shortCondition = ta.crossunder(sma_10, sma_30)

// Idea 2: Using RSI cross 30 & 70 as entry & exit indicator.
// Result: Very bad idea.
// longCondition = ta.crossunder(rsi, 30)
// shortCondition = ta.crossover(rsi, 70)

// Idea 3: Using both sma_10, sma_30 and RSI cross.
// Result: Not a good idea.
// longCondition = ((sma_10 > sma_30) and (rsi < 30))
// shortCondition = ((sma_10 < sma_30) and (rsi > 70))

// Idea 4: Using both MACD slope and RSI cross.
// Result: Not a good idea. Conditions too strict, very few trades.
// longCondition = ((macd_slope > signal_slope) and (rsi < 30))
// shortCondition = ((macd_slope < signal_slope) and (rsi > 70))

// Idea 5: Using both MACD slope, sma10&30 slope.
// Result: 
longCondition = (macd_slope > signal_slope)
shortCondition = (macd_slope < signal_slope)

// Trade execution is determined by crossover / crossunder conditions defined above.
// Use average true range (ATR) to set specific stop losses and take profits.
if longCondition
    stopLoss = low - atr * 2
    takeProfit = high + atr * 2
    // strategy.entry('long', strategy.long, 100, when=rsi >= 50)  // 'when' indicates only enter trade when rsi >= 50.
    strategy.entry('long', strategy.long, 10000)  // 'when' indicates only enter trade when rsi >= 50.
    strategy.exit('exit_long', 'long', stop=stopLoss, limit=takeProfit)

if shortCondition
    stopLoss = high + atr * 2
    takeProfit = low - atr * 2
    // strategy.entry('short', strategy.short, 100, when=rsi <= 50)
    strategy.entry('short', strategy.short, 10000)
    strategy.exit('exit_short', 'short', stop=stopLoss, limit=takeProfit)

plot(sma_10, color=color.new(color.orange, 0))
plot(sma_30, color=color.new(color.green, 0))